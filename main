#include "Graphe.h"
#include <stdlib.h>
#include <stdio.h>
#include <math.h>

#include <string.h>
#define MAX_PAIRS 100 // Nombre maximum de paires
#define MAX_LENGTH 20 // Longueur maximale d'une paire

// Structure représentant une paire de nombres
typedef struct {
    int premier;
    int deuxieme;
} Paire;

// Structure représentant une valeur avec son nombre d'occurrences et son groupe
typedef struct {
    int valeur;
    int occurrences;
    int groupe;
} ValeurAvecOccurrences;

// Structure de graphe pour les liaisons entre les valeurs
typedef struct {
    int valeur;
    int *voisins;
    int nbVoisins;
} Graphe2;

// Fonction de comparaison pour le tri décroissant des valeurs par nombre d'occurrences
int comparer(const void *a, const void *b) {
    return ((ValeurAvecOccurrences *)b)->occurrences - ((ValeurAvecOccurrences *)a)->occurrences;
}




// Ajouter l'arête entre les sommets s1 et s2 du graphe
pSommet* CreerArete(pSommet* sommet,int s1,int s2)
{
    if(sommet[s1]->arc==NULL)
    {
        pArc Newarc=(pArc)malloc(sizeof(struct Arc));
        Newarc->sommet=s2;
        Newarc->arc_suivant=NULL;
        sommet[s1]->arc=Newarc;
        return sommet;
    }

    else
    {
        pArc temp=sommet[s1]->arc;
        while( !(temp->arc_suivant==NULL))
        {
            temp=temp->arc_suivant;
        }
        pArc Newarc=(pArc)malloc(sizeof(struct Arc));
        Newarc->sommet=s2;
        Newarc->arc_suivant=NULL;

        if(temp->sommet>s2)
        {
            Newarc->arc_suivant=temp->arc_suivant;
            Newarc->sommet=temp->sommet;
            temp->sommet=s2;
            temp->arc_suivant=Newarc;
            return sommet;
        }

        temp->arc_suivant=Newarc;
        return sommet;
    }
}

// créer le graphe
Graphe* CreerGraphe(int ordre)
{
    Graphe * Newgraphe=(Graphe*)malloc(sizeof(Graphe));
    Newgraphe->pSommet = (pSommet*)malloc(ordre*sizeof(pSommet));

    for(int i=0; i<ordre; i++)
    {
        Newgraphe->pSommet[i]=(pSommet)malloc(sizeof(struct Sommet));
        Newgraphe->pSommet[i]->valeur=i;
        Newgraphe->pSommet[i]->arc=NULL;
    }
    return Newgraphe;
}


/* La construction du réseau peut se faire à partir d'un fichier dont le nom est passé en paramètre
Le fichier contient : ordre, taille,orientation (0 ou 1)et liste des arcs */
Graphe * lire_graphe(char * nomFichier)
{
    Graphe* graphe;
    FILE * ifs = fopen(nomFichier,"r");
    int taille, orientation, ordre, s1, s2;

    if (!ifs)
    {
        printf("Erreur de lecture fichier\n");
        exit(-1);
    }

    fscanf(ifs,"%d",&ordre);

    graphe=CreerGraphe(ordre); // créer le graphe d'ordre sommets

    fscanf(ifs,"%d",&taille);
    fscanf(ifs,"%d",&orientation);

    graphe->orientation=orientation;
    graphe->ordre=ordre;

    // créer les arêtes du graphe
    for (int i=0; i<taille; ++i)
    {

        fscanf(ifs,"%d%d",&s1,&s2);
        graphe->pSommet=CreerArete(graphe->pSommet, s1, s2);

        if(!orientation)
            graphe->pSommet=CreerArete(graphe->pSommet, s2, s1);
    }

    return graphe;
}

void lire_durees(Graphe* graphe, char* nomFichierDurees) {
    FILE* ifs = fopen(nomFichierDurees, "r");
    if (!ifs) {
        printf("Erreur de lecture fichier de durées\n");
        exit(-1);
    }

    int sommet;
    float duree;
    for (int i = 0; i < graphe->ordre; i++) {
        graphe->pSommet[i]->duree = 0.0;
    }
    // Lire les durées et les ajouter aux sommets du graphe
    while (fscanf(ifs, "%d %f", &sommet, &duree) == 2) {
        if (sommet >= 0 && sommet < graphe->ordre) {
            graphe->pSommet[sommet]->duree = duree;
        } else {
            printf("Erreur : Sommet hors limites\n");
        }
    }

    fclose(ifs); // Fermer le fichier après la lecture
}

int lire_t_cycle(char* nomFichierDurees) {
    FILE* ifs = fopen(nomFichierDurees, "r");
    if (!ifs) {
        printf("Erreur de lecture fichier de durées\n");
        exit(-1);
    }

    int t_cycle;
    fscanf(ifs, "%d", &t_cycle);
    fclose(ifs); // Fermer le fichier après la lecture
    return t_cycle;
}

/*affichage du graphe avec les successeurs de chaque sommet */

void graphe_afficher(Graphe* graphe)
{
    printf("graphe\n");

    if(graphe->orientation)
        printf("oriente\n");
    else
        printf("non oriente\n");

    printf("ordre = %d\n",graphe->ordre);

    printf("listes d'adjacence :\n");

    for (int i=0; i<graphe->ordre; i++)
    {
        printf("sommet %d (duree %.2f) :", graphe->pSommet[i]->valeur, graphe->pSommet[i]->duree);

        pArc arc = graphe->pSommet[i]->arc;

        while (arc != NULL)
        {
            printf(" %d (duree %.2f)", arc->sommet, graphe->pSommet[arc->sommet]->duree);
            arc = arc->arc_suivant;
        }

        printf("\n");
    }
}

int color(Graphe* graphe,FILE * fichier){
    Paire paires[MAX_PAIRS]; // Tableau de paires
    int index = 0;
    char ligne[MAX_LENGTH];
    while (fgets(ligne, sizeof(ligne), fichier) != NULL) {
        // Extraction des nombres de la ligne
        char *token;
        token = strtok(ligne, "{}, ");
        while (token != NULL) {
            paires[index].premier = atoi(token);
            token = strtok(NULL, "{}, ");
            paires[index].deuxieme = atoi(token);
            token = strtok(NULL, "{}, ");

            index++;
            if (index >= MAX_PAIRS) {
                printf("Trop de paires, augmentez MAX_PAIRS.\n");
                break;
            }
        }
    }

    fclose(fichier);

    // Compter les occurrences des valeurs dans les paires
    ValeurAvecOccurrences valeursAvecOccurrences[MAX_PAIRS * 2]; // Pour stocker toutes les valeurs
    int valeursIndex = 0;

    for (int i = 0; i < index; i++) {
        // Vérifier la première valeur de la paire
        int premiereValeur = paires[i].premier;
        int dejaCompte = 0;

        for (int j = 0; j < valeursIndex; j++) {
            if (valeursAvecOccurrences[j].valeur == premiereValeur) {
                valeursAvecOccurrences[j].occurrences++;
                dejaCompte = 1;
                break;
            }
        }

        if (!dejaCompte) {
            valeursAvecOccurrences[valeursIndex].valeur = premiereValeur;
            valeursAvecOccurrences[valeursIndex].occurrences = 1;
            valeursIndex++;
        }

        // Vérifier la deuxième valeur de la paire
        int deuxiemeValeur = paires[i].deuxieme;
        dejaCompte = 0;

        for (int j = 0; j < valeursIndex; j++) {
            if (valeursAvecOccurrences[j].valeur == deuxiemeValeur) {
                valeursAvecOccurrences[j].occurrences++;
                dejaCompte = 1;
                break;
            }
        }

        if (!dejaCompte) {
            valeursAvecOccurrences[valeursIndex].valeur = deuxiemeValeur;
            valeursAvecOccurrences[valeursIndex].occurrences = 1;
            valeursIndex++;
        }
    }

    // Trier les valeurs par nombre d'occurrences (tri décroissant)
    qsort(valeursAvecOccurrences, valeursIndex, sizeof(ValeurAvecOccurrences), comparer);

    // Appliquer l'algorithme de Welsh-Powell pour attribuer les groupes
    int couleur[MAX_PAIRS * 2];
    for (int i = 0; i < valeursIndex; i++) {
        couleur[i] = 0; // Initialiser toutes les couleurs à 0 (non attribué)
    }

    // Trier les sommets par ordre décroissant de degrés
    int ordre[MAX_PAIRS * 2];
    for (int i = 0; i < valeursIndex; i++) {
        ordre[i] = i;
    }

    for (int i = 0; i < valeursIndex - 1; i++) {
        for (int j = 0; j < valeursIndex - i - 1; j++) {
            if (valeursAvecOccurrences[ordre[j]].occurrences < valeursAvecOccurrences[ordre[j + 1]].occurrences) {
                int temp = ordre[j];
                ordre[j] = ordre[j + 1];
                ordre[j + 1] = temp;
            }
        }
    }

    // Appliquer les couleurs
    int groupeActuel = 1;
    for (int i = 0; i < valeursIndex; i++) {
        int sommet = ordre[i];
        if (couleur[sommet] == 0) {
            couleur[sommet] = groupeActuel;

            for (int j = 0; j < valeursIndex; j++) {
                if (i != j && couleur[j] == 0 && sommet != j) {
                    int voisin = j;
                    int estVoisin = 0;
                    for (int k = 0; k < valeursIndex; k++) {
                        if (k != i && k != j && couleur[k] == 0) {
                            if ((paires[k].premier == paires[sommet].premier || paires[k].premier == paires[sommet].deuxieme ||
                                 paires[k].deuxieme == paires[sommet].premier || paires[k].deuxieme == paires[sommet].deuxieme) &&
                                (paires[k].premier == paires[voisin].premier || paires[k].premier == paires[voisin].deuxieme ||
                                 paires[k].deuxieme == paires[voisin].premier || paires[k].deuxieme == paires[voisin].deuxieme)) {
                                estVoisin = 1;
                                break;
                            }
                        }
                    }
                    if (!estVoisin) {
                        couleur[j] = groupeActuel;
                    }
                }
            }

            groupeActuel++;
        }
    }

    // Attribuer les groupes aux valeurs avec occurrences
    for (int i = 0; i < valeursIndex; i++) {
        valeursAvecOccurrences[i].groupe = couleur[i];
    }
    int max = 0;
    // Afficher les groupes attribués aux valeurs
    printf("Groupes attribues aux valeurs en fonction de leurs occurrences :\n");
    for (int i = 0; i < valeursIndex; i++) {
        if(max<valeursAvecOccurrences[i].groupe){
            max += valeursAvecOccurrences[i].groupe;
        }
        printf("Valeur : %d, Occurrences : %d, Groupe : %d\n", valeursAvecOccurrences[i].valeur, valeursAvecOccurrences[i].occurrences, valeursAvecOccurrences[i].groupe);
    }
    // calcul du temps pour les groupes
    float temps_total_groupe[max]; // temps total d'execution de chaque groupe (donc station)
    for (int groupe = 0; groupe < max; groupe++){       // on parcour tous les sommet et on vérifie leur groupe (station)
        for (int i = 0; i < valeursIndex; i++) {
            if(valeursAvecOccurrences[i].groupe > groupe){
                temps_total_groupe[groupe]+= graphe->pSommet[valeursAvecOccurrences[i].valeur]->duree; //
            }
        }
    }
    float temps_max;                        // temps max de toutes les stations
    for(int groupe = 0; groupe < max ; groupe++){    // on parcour toutes les stations pour afficher leur temps
        printf("groupe : ");
        printf("%d ", groupe+1);
        printf("temps : ");
        printf("%f ", temps_total_groupe[groupe]);
        printf("\n");
        if (temps_max < temps_total_groupe[groupe]){ // on met a jour le temps maximum
            temps_max = temps_total_groupe[groupe];
        }
    }


    return temps_max; // on revoie le temps pour voir si celui ci a va être superieur au temps de cycle donné
}


int main() {


    Graphe *g;
    char nom_fichier[50];
    char nom_fichier_durees[50];
    char nom_fichier_t_cycle[50];
    int max;
    FILE *fichier;
    Paire paires[MAX_PAIRS]; // Tableau de paires
    int index = 0;
    char ligne[MAX_LENGTH];

    fichier = fopen("../exclusions.txt", "r");
    if (fichier == NULL) {
        printf("Impossible d'ouvrir le fichier.\n");
        return 1;
    }



    printf("Entrer le nom du fichier de precedances :");//C:\Users\bmart\CLionProjects\pj_th_multi_contrainte\precedences.txt
    gets(nom_fichier);

    g = lire_graphe(nom_fichier);

    printf("Entrer le nom du fichier des durees :");//C:\Users\bmart\CLionProjects\pj_th_multi_contrainte\operations.txt
    gets(nom_fichier_durees);

    lire_durees(g, nom_fichier_durees);

    int seuilTempsCycle;
    printf("Entrer le nom du fichier du temps de cycle :");//C:\Users\bmart\CLionProjects\pj_th_multi_contrainte\temps_cycle.txt
    gets(nom_fichier_t_cycle);

    seuilTempsCycle = lire_t_cycle(nom_fichier_t_cycle);



    graphe_afficher(g);

    max = color(g,fichier);
    if (max < seuilTempsCycle){
        printf("pas assez de stations pour avoir un temps de cycle inferieur a celui souhaite\n");
    }
    else printf("assez de stations pour avoir un temps de cycle inferieur a celui souhaite\n");
    return 0;
}
