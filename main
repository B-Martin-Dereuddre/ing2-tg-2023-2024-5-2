#include "Graphe.h"
#include <stdlib.h>
#include <stdio.h>
#include <math.h>

/* affichage des successeurs du sommet num*/
void afficher_successeurs(pSommet * sommet, int num)
{

    printf(" sommet %d :\n",num);

    pArc arc=sommet[num]->arc;

    while(arc!=NULL)
    {
        printf("%d ",arc->sommet);
        arc=arc->arc_suivant;
    }

}


// Ajouter l'arête entre les sommets s1 et s2 du graphe
pSommet* CreerArete(pSommet* sommet,int s1,int s2)
{
    if(sommet[s1]->arc==NULL)
    {
        pArc Newarc=(pArc)malloc(sizeof(struct Arc));
        Newarc->sommet=s2;
        Newarc->arc_suivant=NULL;
        sommet[s1]->arc=Newarc;
        return sommet;
    }

    else
    {
        pArc temp=sommet[s1]->arc;
        while( !(temp->arc_suivant==NULL))
        {
            temp=temp->arc_suivant;
        }
        pArc Newarc=(pArc)malloc(sizeof(struct Arc));
        Newarc->sommet=s2;
        Newarc->arc_suivant=NULL;

        if(temp->sommet>s2)
        {
            Newarc->arc_suivant=temp->arc_suivant;
            Newarc->sommet=temp->sommet;
            temp->sommet=s2;
            temp->arc_suivant=Newarc;
            return sommet;
        }

        temp->arc_suivant=Newarc;
        return sommet;
    }
}

// créer le graphe
Graphe* CreerGraphe(int ordre)
{
    Graphe * Newgraphe=(Graphe*)malloc(sizeof(Graphe));
    Newgraphe->pSommet = (pSommet*)malloc(ordre*sizeof(pSommet));

    for(int i=0; i<ordre; i++)
    {
        Newgraphe->pSommet[i]=(pSommet)malloc(sizeof(struct Sommet));
        Newgraphe->pSommet[i]->valeur=i;
        Newgraphe->pSommet[i]->arc=NULL;
    }
    return Newgraphe;
}


/* La construction du réseau peut se faire à partir d'un fichier dont le nom est passé en paramètre
Le fichier contient : ordre, taille,orientation (0 ou 1)et liste des arcs */
Graphe * lire_graphe(char * nomFichier)
{
    Graphe* graphe;
    FILE * ifs = fopen(nomFichier,"r");
    int taille, orientation, ordre, s1, s2;

    if (!ifs)
    {
        printf("Erreur de lecture fichier\n");
        exit(-1);



    }

    fscanf(ifs,"%d",&ordre);

    graphe=CreerGraphe(ordre); // créer le graphe d'ordre sommets

    fscanf(ifs,"%d",&taille);
    fscanf(ifs,"%d",&orientation);

    graphe->orientation=orientation;
    graphe->ordre=ordre;

    // créer les arêtes du graphe
    for (int i=0; i<taille; ++i)
    {
        printf("test ");
        fscanf(ifs,"%d%d",&s1,&s2);
        graphe->pSommet=CreerArete(graphe->pSommet, s1, s2);

        if(!orientation)
            graphe->pSommet=CreerArete(graphe->pSommet, s2, s1);
    }

    return graphe;
}

void lire_durees(Graphe* graphe, char* nomFichierDurees) {
    FILE* ifs = fopen(nomFichierDurees, "r");
    if (!ifs) {
        printf("Erreur de lecture fichier de durées\n");
        exit(-1);
    }

    int sommet;
    float duree;
    for (int i = 0; i < graphe->ordre; i++) {
        graphe->pSommet[i]->duree = 0.0;
    }
    // Lire les durées et les ajouter aux sommets du graphe
    while (fscanf(ifs, "%d %f", &sommet, &duree) == 2) {
        if (sommet >= 0 && sommet < graphe->ordre) {
            graphe->pSommet[sommet]->duree = duree;
        } else {
            printf("Erreur : Sommet hors limites\n");
        }
    }

    fclose(ifs); // Fermer le fichier après la lecture
}

/*affichage du graphe avec les successeurs de chaque sommet */

void graphe_afficher(Graphe* graphe)
{
    printf("graphe\n");

    if(graphe->orientation)
        printf("oriente\n");
    else
        printf("non oriente\n");

    printf("ordre = %d\n",graphe->ordre);

    printf("listes d'adjacence :\n");

    for (int i=0; i<graphe->ordre; i++)
    {
        printf("sommet %d (duree %.2f) :", graphe->pSommet[i]->valeur, graphe->pSommet[i]->duree);

        pArc arc = graphe->pSommet[i]->arc;

        while (arc != NULL)
        {
            printf(" %d (duree %.2f)", arc->sommet, graphe->pSommet[arc->sommet]->duree);
            arc = arc->arc_suivant;
        }

        printf("\n");
    }
}




void ParcourLongueur(Graphe * g,int s, int taille){

    if(g->pSommet[s]->couleur == 'B'){
        printf("%d,",g->pSommet[s]->valeur);
        g->pSommet[s]->couleur='N';
        pArc Temparc=g->pSommet[s]->arc;
        while(Temparc!=NULL){
            if (g->pSommet[Temparc->sommet]->couleur == 'B') {
                ParcourLongueur(g, Temparc->sommet,taille);
            }
            Temparc=Temparc->arc_suivant;
        }
    }


}

void sommet_cible(Graphe * g,int s, int taille,  int cible){
    if(g->pSommet[s]->couleur == 'B'){
        printf("%d,",g->pSommet[s]->valeur);
        if (g->pSommet[s]->valeur == cible){
            return;
        }
        g->pSommet[s]->couleur='N';
        pArc Temparc=g->pSommet[s]->arc;
        while(Temparc!=NULL){
            if (g->pSommet[Temparc->sommet]->couleur == 'B') {
                sommet_cible(g, Temparc->sommet,taille,cible);
                if (g->pSommet[Temparc->sommet]->couleur == 'N') {
                    return;
                }
            }
            Temparc=Temparc->arc_suivant;
        }

    }
}

int* trouver_source(Graphe* graphe, int* nbSources) {
    // Tableau pour marquer les sommets ayant des prédécesseurs entrants
    int* aDesPredecesseurs = (int*)malloc(graphe->ordre * sizeof(int));

    // Initialiser le tableau à false (0)
    for (int i = 0; i < graphe->ordre; i++) {
        aDesPredecesseurs[i] = 0;
    }

    // Parcourir tous les sommets et marquer ceux ayant des prédécesseurs
    for (int i = 0; i < graphe->ordre; i++) {
        pArc arc = graphe->pSommet[i]->arc;
        while (arc != NULL) {
            aDesPredecesseurs[arc->sommet] = 1;
            arc = arc->arc_suivant;
        }
    }

    // Compter les sources du graphe (sommets sans prédécesseurs entrants et avec au moins un successeur sortant)
    *nbSources = 0;
    for (int i = 0; i < graphe->ordre; i++) {
        if (!aDesPredecesseurs[i] && graphe->pSommet[i]->arc != NULL) {
            (*nbSources)++;
        }
    }

    // Allouer de la mémoire pour stocker les indices des sources
    int* sources = (int*)malloc(*nbSources * sizeof(int));

    // Remplir le tableau avec les indices des sources du graphe
    int indexSource = 0;
    for (int i = 0; i < graphe->ordre; i++) {
        if (!aDesPredecesseurs[i] && graphe->pSommet[i]->arc != NULL) {
            sources[indexSource++] = i;
        }
    }

    // Libérer la mémoire allouée
    free(aDesPredecesseurs);

    return sources;
}

typedef struct {
    float auPlusTot;
    float auPlusTard;
} PertInfo;

void parcourir_et_mettre_a_jour_dates(Graphe* graphe, PertInfo* indices, int sommet, float* derniereTache) {
    pArc arc = graphe->pSommet[sommet]->arc;

    // Variables pour stocker les tâches pouvant s'exécuter simultanément
    float debutPossible = indices[sommet].auPlusTard; // Début possible de la tâche actuelle
    float finPossible = *derniereTache; // Fin possible de la tâche précédente

    while (arc != NULL) {
        int successeur = arc->sommet;
        float dureeArc = graphe->pSommet[successeur]->duree;

        // Vérifiez si la tâche successeur a des prédécesseurs autres que la tâche actuelle
        int aDesPredecesseursAutres = 0;
        pArc predArc = graphe->pSommet[successeur]->arc;
        while (predArc != NULL) {
            if (predArc->sommet != sommet) {
                aDesPredecesseursAutres = 1;
                break;
            }
            predArc = predArc->arc_suivant;
        }

        // Si la tâche successeur n'a pas d'autres prédécesseurs, elle peut commencer simultanément
        if (!aDesPredecesseursAutres) {
            // Mettez à jour la date au plus tôt pour la tâche successeur
            indices[successeur].auPlusTot = fmax(indices[successeur].auPlusTot, finPossible);

            // Mettez à jour la date au plus tard pour la tâche successeur
            indices[successeur].auPlusTard = indices[successeur].auPlusTot + dureeArc;

            // Mettez à jour la fin possible pour les tâches suivantes
            finPossible = indices[successeur].auPlusTard;

            // Appel récursif pour parcourir les successeurs
            parcourir_et_mettre_a_jour_dates(graphe, indices, successeur, derniereTache);
        } else {
            // Si la tâche successeur a d'autres prédécesseurs, elle doit attendre que la tâche actuelle soit terminée
            indices[successeur].auPlusTot = fmax(indices[successeur].auPlusTot, indices[sommet].auPlusTard);

            // Mettez à jour la date au plus tard pour la tâche successeur
            indices[successeur].auPlusTard = indices[successeur].auPlusTot + dureeArc;

            // Mettez à jour la fin possible pour les tâches suivantes
            finPossible = indices[successeur].auPlusTard;

            // Appel récursif pour parcourir les successeurs
            parcourir_et_mettre_a_jour_dates(graphe, indices, successeur, derniereTache);
        }

        arc = arc->arc_suivant;
    }

    // Mettez à jour la fin possible de la tâche actuelle pour les tâches suivantes
    *derniereTache = fmax(debutPossible, finPossible);
}

void pert_calculer_et_afficher(Graphe* graphe) {
    int nbSources;
    int* sources = trouver_source(graphe, &nbSources);

    // Allouer de l'espace pour les indices PERT
    PertInfo* indices = (PertInfo*)malloc(graphe->ordre * sizeof(PertInfo));

    // Initialiser les indices PERT
    for (int i = 0; i < graphe->ordre; i++) {
        indices[i].auPlusTot = 0.0;
        indices[i].auPlusTard = 0.0; // Initialiser au maximum de float
    }

    // Calculer les indices PERT à partir des sources
    for (int i = 0; i < nbSources; i++) {
        int source = sources[i];
        indices[source].auPlusTot = 0.0;
        indices[source].auPlusTard = graphe->pSommet[source]->duree; // Initialiser au temps de la tâche source
    }

    // Calculer les dates au plus tard pour chaque tâche
    for (int i = 0; i < nbSources; i++) {
        int source = sources[i];
        float derniereTache = 0.0; // Initialisez avec le début du projet
        parcourir_et_mettre_a_jour_dates(graphe, indices, source, &derniereTache);
    }

    // Afficher les indices PERT
    printf("Indices PERT :\n");
    for (int i = 0; i < graphe->ordre; i++) {
        printf("Tache %d : Au plus tot = %.2f, Au plus tard = %.2f\n", i, indices[i].auPlusTot, indices[i].auPlusTard);
    }

    // Libérer la mémoire allouée
    free(sources);
    free(indices);
}

int main()
{


    Graphe* g;
    char nom_fichier[50];
    char nom_fichier_durees[50];

    printf("Entrer le nom du fichier du labyrinthe:");//C:\Users\bmart\CLionProjects\projet_th_graphe\precedences.txt
    gets(nom_fichier);

    g = lire_graphe(nom_fichier);

    printf("Entrer le nom du fichier des durees : ");//C:\Users\bmart\CLionProjects\projet_th_graphe\operations.txt
    gets(nom_fichier_durees);

    lire_durees(g, nom_fichier_durees);

    graphe_afficher(g);

    // Calculer et afficher les indices PERT
    pert_calculer_et_afficher(g);

    return 0;


}
